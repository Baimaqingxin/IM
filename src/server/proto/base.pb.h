// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_base_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_base_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_base_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_base_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_base_2eproto;
namespace im {
class ChatSessionInfo;
class ChatSessionInfoDefaultTypeInternal;
extern ChatSessionInfoDefaultTypeInternal _ChatSessionInfo_default_instance_;
class FileDownloadData;
class FileDownloadDataDefaultTypeInternal;
extern FileDownloadDataDefaultTypeInternal _FileDownloadData_default_instance_;
class FileMessageInfo;
class FileMessageInfoDefaultTypeInternal;
extern FileMessageInfoDefaultTypeInternal _FileMessageInfo_default_instance_;
class FileUploadData;
class FileUploadDataDefaultTypeInternal;
extern FileUploadDataDefaultTypeInternal _FileUploadData_default_instance_;
class ImageMessageInfo;
class ImageMessageInfoDefaultTypeInternal;
extern ImageMessageInfoDefaultTypeInternal _ImageMessageInfo_default_instance_;
class MessageContent;
class MessageContentDefaultTypeInternal;
extern MessageContentDefaultTypeInternal _MessageContent_default_instance_;
class MessageInfo;
class MessageInfoDefaultTypeInternal;
extern MessageInfoDefaultTypeInternal _MessageInfo_default_instance_;
class SpeechMessageInfo;
class SpeechMessageInfoDefaultTypeInternal;
extern SpeechMessageInfoDefaultTypeInternal _SpeechMessageInfo_default_instance_;
class StringMessageInfo;
class StringMessageInfoDefaultTypeInternal;
extern StringMessageInfoDefaultTypeInternal _StringMessageInfo_default_instance_;
class UserInfo;
class UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace im
PROTOBUF_NAMESPACE_OPEN
template<> ::im::ChatSessionInfo* Arena::CreateMaybeMessage<::im::ChatSessionInfo>(Arena*);
template<> ::im::FileDownloadData* Arena::CreateMaybeMessage<::im::FileDownloadData>(Arena*);
template<> ::im::FileMessageInfo* Arena::CreateMaybeMessage<::im::FileMessageInfo>(Arena*);
template<> ::im::FileUploadData* Arena::CreateMaybeMessage<::im::FileUploadData>(Arena*);
template<> ::im::ImageMessageInfo* Arena::CreateMaybeMessage<::im::ImageMessageInfo>(Arena*);
template<> ::im::MessageContent* Arena::CreateMaybeMessage<::im::MessageContent>(Arena*);
template<> ::im::MessageInfo* Arena::CreateMaybeMessage<::im::MessageInfo>(Arena*);
template<> ::im::SpeechMessageInfo* Arena::CreateMaybeMessage<::im::SpeechMessageInfo>(Arena*);
template<> ::im::StringMessageInfo* Arena::CreateMaybeMessage<::im::StringMessageInfo>(Arena*);
template<> ::im::UserInfo* Arena::CreateMaybeMessage<::im::UserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace im {

enum MessageType : int {
  STRING = 0,
  IMAGE = 1,
  FILE = 2,
  SPEECH = 3,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = STRING;
constexpr MessageType MessageType_MAX = SPEECH;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class UserInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const final {
    return CreateMaybeMessage<UserInfo>(nullptr);
  }

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kNicknameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kPhoneFieldNumber = 4,
    kAvatarFieldNumber = 5,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  void set_user_id(const std::string& value);
  void set_user_id(std::string&& value);
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  std::string* mutable_user_id();
  std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  void set_nickname(const std::string& value);
  void set_nickname(std::string&& value);
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  std::string* mutable_nickname();
  std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string phone = 4;
  void clear_phone();
  const std::string& phone() const;
  void set_phone(const std::string& value);
  void set_phone(std::string&& value);
  void set_phone(const char* value);
  void set_phone(const char* value, size_t size);
  std::string* mutable_phone();
  std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // bytes avatar = 5;
  void clear_avatar();
  const std::string& avatar() const;
  void set_avatar(const std::string& value);
  void set_avatar(std::string&& value);
  void set_avatar(const char* value);
  void set_avatar(const void* value, size_t size);
  std::string* mutable_avatar();
  std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // @@protoc_insertion_point(class_scope:im.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class ChatSessionInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.ChatSessionInfo) */ {
 public:
  inline ChatSessionInfo() : ChatSessionInfo(nullptr) {}
  virtual ~ChatSessionInfo();

  ChatSessionInfo(const ChatSessionInfo& from);
  ChatSessionInfo(ChatSessionInfo&& from) noexcept
    : ChatSessionInfo() {
    *this = ::std::move(from);
  }

  inline ChatSessionInfo& operator=(const ChatSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatSessionInfo& operator=(ChatSessionInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChatSessionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatSessionInfo* internal_default_instance() {
    return reinterpret_cast<const ChatSessionInfo*>(
               &_ChatSessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChatSessionInfo& a, ChatSessionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatSessionInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatSessionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChatSessionInfo* New() const final {
    return CreateMaybeMessage<ChatSessionInfo>(nullptr);
  }

  ChatSessionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChatSessionInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChatSessionInfo& from);
  void MergeFrom(const ChatSessionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatSessionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.ChatSessionInfo";
  }
  protected:
  explicit ChatSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSingleChatFriendIdFieldNumber = 1,
    kChatSessionIdFieldNumber = 2,
    kChatSessionNameFieldNumber = 3,
    kAvatarFieldNumber = 5,
    kPrevMessageFieldNumber = 4,
  };
  // string single_chat_friend_id = 1;
  bool has_single_chat_friend_id() const;
  private:
  bool _internal_has_single_chat_friend_id() const;
  public:
  void clear_single_chat_friend_id();
  const std::string& single_chat_friend_id() const;
  void set_single_chat_friend_id(const std::string& value);
  void set_single_chat_friend_id(std::string&& value);
  void set_single_chat_friend_id(const char* value);
  void set_single_chat_friend_id(const char* value, size_t size);
  std::string* mutable_single_chat_friend_id();
  std::string* release_single_chat_friend_id();
  void set_allocated_single_chat_friend_id(std::string* single_chat_friend_id);
  private:
  const std::string& _internal_single_chat_friend_id() const;
  void _internal_set_single_chat_friend_id(const std::string& value);
  std::string* _internal_mutable_single_chat_friend_id();
  public:

  // string chat_session_id = 2;
  void clear_chat_session_id();
  const std::string& chat_session_id() const;
  void set_chat_session_id(const std::string& value);
  void set_chat_session_id(std::string&& value);
  void set_chat_session_id(const char* value);
  void set_chat_session_id(const char* value, size_t size);
  std::string* mutable_chat_session_id();
  std::string* release_chat_session_id();
  void set_allocated_chat_session_id(std::string* chat_session_id);
  private:
  const std::string& _internal_chat_session_id() const;
  void _internal_set_chat_session_id(const std::string& value);
  std::string* _internal_mutable_chat_session_id();
  public:

  // string chat_session_name = 3;
  void clear_chat_session_name();
  const std::string& chat_session_name() const;
  void set_chat_session_name(const std::string& value);
  void set_chat_session_name(std::string&& value);
  void set_chat_session_name(const char* value);
  void set_chat_session_name(const char* value, size_t size);
  std::string* mutable_chat_session_name();
  std::string* release_chat_session_name();
  void set_allocated_chat_session_name(std::string* chat_session_name);
  private:
  const std::string& _internal_chat_session_name() const;
  void _internal_set_chat_session_name(const std::string& value);
  std::string* _internal_mutable_chat_session_name();
  public:

  // bytes avatar = 5;
  bool has_avatar() const;
  private:
  bool _internal_has_avatar() const;
  public:
  void clear_avatar();
  const std::string& avatar() const;
  void set_avatar(const std::string& value);
  void set_avatar(std::string&& value);
  void set_avatar(const char* value);
  void set_avatar(const void* value, size_t size);
  std::string* mutable_avatar();
  std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // .im.MessageInfo prev_message = 4;
  bool has_prev_message() const;
  private:
  bool _internal_has_prev_message() const;
  public:
  void clear_prev_message();
  const ::im::MessageInfo& prev_message() const;
  ::im::MessageInfo* release_prev_message();
  ::im::MessageInfo* mutable_prev_message();
  void set_allocated_prev_message(::im::MessageInfo* prev_message);
  private:
  const ::im::MessageInfo& _internal_prev_message() const;
  ::im::MessageInfo* _internal_mutable_prev_message();
  public:
  void unsafe_arena_set_allocated_prev_message(
      ::im::MessageInfo* prev_message);
  ::im::MessageInfo* unsafe_arena_release_prev_message();

  // @@protoc_insertion_point(class_scope:im.ChatSessionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr single_chat_friend_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_session_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
  ::im::MessageInfo* prev_message_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class StringMessageInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.StringMessageInfo) */ {
 public:
  inline StringMessageInfo() : StringMessageInfo(nullptr) {}
  virtual ~StringMessageInfo();

  StringMessageInfo(const StringMessageInfo& from);
  StringMessageInfo(StringMessageInfo&& from) noexcept
    : StringMessageInfo() {
    *this = ::std::move(from);
  }

  inline StringMessageInfo& operator=(const StringMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringMessageInfo& operator=(StringMessageInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StringMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringMessageInfo* internal_default_instance() {
    return reinterpret_cast<const StringMessageInfo*>(
               &_StringMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StringMessageInfo& a, StringMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StringMessageInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringMessageInfo* New() const final {
    return CreateMaybeMessage<StringMessageInfo>(nullptr);
  }

  StringMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringMessageInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StringMessageInfo& from);
  void MergeFrom(const StringMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMessageInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.StringMessageInfo";
  }
  protected:
  explicit StringMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:im.StringMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class ImageMessageInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.ImageMessageInfo) */ {
 public:
  inline ImageMessageInfo() : ImageMessageInfo(nullptr) {}
  virtual ~ImageMessageInfo();

  ImageMessageInfo(const ImageMessageInfo& from);
  ImageMessageInfo(ImageMessageInfo&& from) noexcept
    : ImageMessageInfo() {
    *this = ::std::move(from);
  }

  inline ImageMessageInfo& operator=(const ImageMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageMessageInfo& operator=(ImageMessageInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageMessageInfo* internal_default_instance() {
    return reinterpret_cast<const ImageMessageInfo*>(
               &_ImageMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ImageMessageInfo& a, ImageMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageMessageInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageMessageInfo* New() const final {
    return CreateMaybeMessage<ImageMessageInfo>(nullptr);
  }

  ImageMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageMessageInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageMessageInfo& from);
  void MergeFrom(const ImageMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageMessageInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.ImageMessageInfo";
  }
  protected:
  explicit ImageMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kImageContentFieldNumber = 2,
  };
  // string file_id = 1;
  bool has_file_id() const;
  private:
  bool _internal_has_file_id() const;
  public:
  void clear_file_id();
  const std::string& file_id() const;
  void set_file_id(const std::string& value);
  void set_file_id(std::string&& value);
  void set_file_id(const char* value);
  void set_file_id(const char* value, size_t size);
  std::string* mutable_file_id();
  std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // bytes image_content = 2;
  bool has_image_content() const;
  private:
  bool _internal_has_image_content() const;
  public:
  void clear_image_content();
  const std::string& image_content() const;
  void set_image_content(const std::string& value);
  void set_image_content(std::string&& value);
  void set_image_content(const char* value);
  void set_image_content(const void* value, size_t size);
  std::string* mutable_image_content();
  std::string* release_image_content();
  void set_allocated_image_content(std::string* image_content);
  private:
  const std::string& _internal_image_content() const;
  void _internal_set_image_content(const std::string& value);
  std::string* _internal_mutable_image_content();
  public:

  // @@protoc_insertion_point(class_scope:im.ImageMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_content_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class FileMessageInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.FileMessageInfo) */ {
 public:
  inline FileMessageInfo() : FileMessageInfo(nullptr) {}
  virtual ~FileMessageInfo();

  FileMessageInfo(const FileMessageInfo& from);
  FileMessageInfo(FileMessageInfo&& from) noexcept
    : FileMessageInfo() {
    *this = ::std::move(from);
  }

  inline FileMessageInfo& operator=(const FileMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMessageInfo& operator=(FileMessageInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileMessageInfo* internal_default_instance() {
    return reinterpret_cast<const FileMessageInfo*>(
               &_FileMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileMessageInfo& a, FileMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileMessageInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileMessageInfo* New() const final {
    return CreateMaybeMessage<FileMessageInfo>(nullptr);
  }

  FileMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileMessageInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileMessageInfo& from);
  void MergeFrom(const FileMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileMessageInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.FileMessageInfo";
  }
  protected:
  explicit FileMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kFileNameFieldNumber = 3,
    kFileContentsFieldNumber = 4,
    kFileSizeFieldNumber = 2,
  };
  // string file_id = 1;
  bool has_file_id() const;
  private:
  bool _internal_has_file_id() const;
  public:
  void clear_file_id();
  const std::string& file_id() const;
  void set_file_id(const std::string& value);
  void set_file_id(std::string&& value);
  void set_file_id(const char* value);
  void set_file_id(const char* value, size_t size);
  std::string* mutable_file_id();
  std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string file_name = 3;
  bool has_file_name() const;
  private:
  bool _internal_has_file_name() const;
  public:
  void clear_file_name();
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // bytes file_contents = 4;
  bool has_file_contents() const;
  private:
  bool _internal_has_file_contents() const;
  public:
  void clear_file_contents();
  const std::string& file_contents() const;
  void set_file_contents(const std::string& value);
  void set_file_contents(std::string&& value);
  void set_file_contents(const char* value);
  void set_file_contents(const void* value, size_t size);
  std::string* mutable_file_contents();
  std::string* release_file_contents();
  void set_allocated_file_contents(std::string* file_contents);
  private:
  const std::string& _internal_file_contents() const;
  void _internal_set_file_contents(const std::string& value);
  std::string* _internal_mutable_file_contents();
  public:

  // int64 file_size = 2;
  bool has_file_size() const;
  private:
  bool _internal_has_file_size() const;
  public:
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::int64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:im.FileMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_contents_;
  ::PROTOBUF_NAMESPACE_ID::int64 file_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class SpeechMessageInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.SpeechMessageInfo) */ {
 public:
  inline SpeechMessageInfo() : SpeechMessageInfo(nullptr) {}
  virtual ~SpeechMessageInfo();

  SpeechMessageInfo(const SpeechMessageInfo& from);
  SpeechMessageInfo(SpeechMessageInfo&& from) noexcept
    : SpeechMessageInfo() {
    *this = ::std::move(from);
  }

  inline SpeechMessageInfo& operator=(const SpeechMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeechMessageInfo& operator=(SpeechMessageInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeechMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeechMessageInfo* internal_default_instance() {
    return reinterpret_cast<const SpeechMessageInfo*>(
               &_SpeechMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SpeechMessageInfo& a, SpeechMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeechMessageInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeechMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeechMessageInfo* New() const final {
    return CreateMaybeMessage<SpeechMessageInfo>(nullptr);
  }

  SpeechMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeechMessageInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeechMessageInfo& from);
  void MergeFrom(const SpeechMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechMessageInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.SpeechMessageInfo";
  }
  protected:
  explicit SpeechMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kFileContentsFieldNumber = 2,
  };
  // string file_id = 1;
  bool has_file_id() const;
  private:
  bool _internal_has_file_id() const;
  public:
  void clear_file_id();
  const std::string& file_id() const;
  void set_file_id(const std::string& value);
  void set_file_id(std::string&& value);
  void set_file_id(const char* value);
  void set_file_id(const char* value, size_t size);
  std::string* mutable_file_id();
  std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // bytes file_contents = 2;
  bool has_file_contents() const;
  private:
  bool _internal_has_file_contents() const;
  public:
  void clear_file_contents();
  const std::string& file_contents() const;
  void set_file_contents(const std::string& value);
  void set_file_contents(std::string&& value);
  void set_file_contents(const char* value);
  void set_file_contents(const void* value, size_t size);
  std::string* mutable_file_contents();
  std::string* release_file_contents();
  void set_allocated_file_contents(std::string* file_contents);
  private:
  const std::string& _internal_file_contents() const;
  void _internal_set_file_contents(const std::string& value);
  std::string* _internal_mutable_file_contents();
  public:

  // @@protoc_insertion_point(class_scope:im.SpeechMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_contents_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class MessageContent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.MessageContent) */ {
 public:
  inline MessageContent() : MessageContent(nullptr) {}
  virtual ~MessageContent();

  MessageContent(const MessageContent& from);
  MessageContent(MessageContent&& from) noexcept
    : MessageContent() {
    *this = ::std::move(from);
  }

  inline MessageContent& operator=(const MessageContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageContent& operator=(MessageContent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageContent& default_instance();

  enum MsgContentCase {
    kStringMessage = 2,
    kFileMessage = 3,
    kSpeechMessage = 4,
    kImageMessage = 5,
    MSG_CONTENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageContent* internal_default_instance() {
    return reinterpret_cast<const MessageContent*>(
               &_MessageContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MessageContent& a, MessageContent& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageContent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageContent* New() const final {
    return CreateMaybeMessage<MessageContent>(nullptr);
  }

  MessageContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageContent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageContent& from);
  void MergeFrom(const MessageContent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageContent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.MessageContent";
  }
  protected:
  explicit MessageContent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kStringMessageFieldNumber = 2,
    kFileMessageFieldNumber = 3,
    kSpeechMessageFieldNumber = 4,
    kImageMessageFieldNumber = 5,
  };
  // .im.MessageType message_type = 1;
  void clear_message_type();
  ::im::MessageType message_type() const;
  void set_message_type(::im::MessageType value);
  private:
  ::im::MessageType _internal_message_type() const;
  void _internal_set_message_type(::im::MessageType value);
  public:

  // .im.StringMessageInfo string_message = 2;
  bool has_string_message() const;
  private:
  bool _internal_has_string_message() const;
  public:
  void clear_string_message();
  const ::im::StringMessageInfo& string_message() const;
  ::im::StringMessageInfo* release_string_message();
  ::im::StringMessageInfo* mutable_string_message();
  void set_allocated_string_message(::im::StringMessageInfo* string_message);
  private:
  const ::im::StringMessageInfo& _internal_string_message() const;
  ::im::StringMessageInfo* _internal_mutable_string_message();
  public:
  void unsafe_arena_set_allocated_string_message(
      ::im::StringMessageInfo* string_message);
  ::im::StringMessageInfo* unsafe_arena_release_string_message();

  // .im.FileMessageInfo file_message = 3;
  bool has_file_message() const;
  private:
  bool _internal_has_file_message() const;
  public:
  void clear_file_message();
  const ::im::FileMessageInfo& file_message() const;
  ::im::FileMessageInfo* release_file_message();
  ::im::FileMessageInfo* mutable_file_message();
  void set_allocated_file_message(::im::FileMessageInfo* file_message);
  private:
  const ::im::FileMessageInfo& _internal_file_message() const;
  ::im::FileMessageInfo* _internal_mutable_file_message();
  public:
  void unsafe_arena_set_allocated_file_message(
      ::im::FileMessageInfo* file_message);
  ::im::FileMessageInfo* unsafe_arena_release_file_message();

  // .im.SpeechMessageInfo speech_message = 4;
  bool has_speech_message() const;
  private:
  bool _internal_has_speech_message() const;
  public:
  void clear_speech_message();
  const ::im::SpeechMessageInfo& speech_message() const;
  ::im::SpeechMessageInfo* release_speech_message();
  ::im::SpeechMessageInfo* mutable_speech_message();
  void set_allocated_speech_message(::im::SpeechMessageInfo* speech_message);
  private:
  const ::im::SpeechMessageInfo& _internal_speech_message() const;
  ::im::SpeechMessageInfo* _internal_mutable_speech_message();
  public:
  void unsafe_arena_set_allocated_speech_message(
      ::im::SpeechMessageInfo* speech_message);
  ::im::SpeechMessageInfo* unsafe_arena_release_speech_message();

  // .im.ImageMessageInfo image_message = 5;
  bool has_image_message() const;
  private:
  bool _internal_has_image_message() const;
  public:
  void clear_image_message();
  const ::im::ImageMessageInfo& image_message() const;
  ::im::ImageMessageInfo* release_image_message();
  ::im::ImageMessageInfo* mutable_image_message();
  void set_allocated_image_message(::im::ImageMessageInfo* image_message);
  private:
  const ::im::ImageMessageInfo& _internal_image_message() const;
  ::im::ImageMessageInfo* _internal_mutable_image_message();
  public:
  void unsafe_arena_set_allocated_image_message(
      ::im::ImageMessageInfo* image_message);
  ::im::ImageMessageInfo* unsafe_arena_release_image_message();

  void clear_msg_content();
  MsgContentCase msg_content_case() const;
  // @@protoc_insertion_point(class_scope:im.MessageContent)
 private:
  class _Internal;
  void set_has_string_message();
  void set_has_file_message();
  void set_has_speech_message();
  void set_has_image_message();

  inline bool has_msg_content() const;
  inline void clear_has_msg_content();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int message_type_;
  union MsgContentUnion {
    MsgContentUnion() {}
    ::im::StringMessageInfo* string_message_;
    ::im::FileMessageInfo* file_message_;
    ::im::SpeechMessageInfo* speech_message_;
    ::im::ImageMessageInfo* image_message_;
  } msg_content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class MessageInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.MessageInfo) */ {
 public:
  inline MessageInfo() : MessageInfo(nullptr) {}
  virtual ~MessageInfo();

  MessageInfo(const MessageInfo& from);
  MessageInfo(MessageInfo&& from) noexcept
    : MessageInfo() {
    *this = ::std::move(from);
  }

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageInfo& operator=(MessageInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageInfo* internal_default_instance() {
    return reinterpret_cast<const MessageInfo*>(
               &_MessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MessageInfo& a, MessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageInfo* New() const final {
    return CreateMaybeMessage<MessageInfo>(nullptr);
  }

  MessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageInfo& from);
  void MergeFrom(const MessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.MessageInfo";
  }
  protected:
  explicit MessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kChatSessionIdFieldNumber = 2,
    kSenderFieldNumber = 4,
    kMessageFieldNumber = 5,
    kTimestampFieldNumber = 3,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  void set_message_id(const std::string& value);
  void set_message_id(std::string&& value);
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  std::string* mutable_message_id();
  std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string chat_session_id = 2;
  void clear_chat_session_id();
  const std::string& chat_session_id() const;
  void set_chat_session_id(const std::string& value);
  void set_chat_session_id(std::string&& value);
  void set_chat_session_id(const char* value);
  void set_chat_session_id(const char* value, size_t size);
  std::string* mutable_chat_session_id();
  std::string* release_chat_session_id();
  void set_allocated_chat_session_id(std::string* chat_session_id);
  private:
  const std::string& _internal_chat_session_id() const;
  void _internal_set_chat_session_id(const std::string& value);
  std::string* _internal_mutable_chat_session_id();
  public:

  // .im.UserInfo sender = 4;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::im::UserInfo& sender() const;
  ::im::UserInfo* release_sender();
  ::im::UserInfo* mutable_sender();
  void set_allocated_sender(::im::UserInfo* sender);
  private:
  const ::im::UserInfo& _internal_sender() const;
  ::im::UserInfo* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::im::UserInfo* sender);
  ::im::UserInfo* unsafe_arena_release_sender();

  // .im.MessageContent message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::im::MessageContent& message() const;
  ::im::MessageContent* release_message();
  ::im::MessageContent* mutable_message();
  void set_allocated_message(::im::MessageContent* message);
  private:
  const ::im::MessageContent& _internal_message() const;
  ::im::MessageContent* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::im::MessageContent* message);
  ::im::MessageContent* unsafe_arena_release_message();

  // int64 timestamp = 3;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:im.MessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_session_id_;
  ::im::UserInfo* sender_;
  ::im::MessageContent* message_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class FileDownloadData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.FileDownloadData) */ {
 public:
  inline FileDownloadData() : FileDownloadData(nullptr) {}
  virtual ~FileDownloadData();

  FileDownloadData(const FileDownloadData& from);
  FileDownloadData(FileDownloadData&& from) noexcept
    : FileDownloadData() {
    *this = ::std::move(from);
  }

  inline FileDownloadData& operator=(const FileDownloadData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileDownloadData& operator=(FileDownloadData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileDownloadData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileDownloadData* internal_default_instance() {
    return reinterpret_cast<const FileDownloadData*>(
               &_FileDownloadData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FileDownloadData& a, FileDownloadData& b) {
    a.Swap(&b);
  }
  inline void Swap(FileDownloadData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileDownloadData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileDownloadData* New() const final {
    return CreateMaybeMessage<FileDownloadData>(nullptr);
  }

  FileDownloadData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileDownloadData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileDownloadData& from);
  void MergeFrom(const FileDownloadData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileDownloadData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.FileDownloadData";
  }
  protected:
  explicit FileDownloadData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kFileContentFieldNumber = 2,
  };
  // string file_id = 1;
  void clear_file_id();
  const std::string& file_id() const;
  void set_file_id(const std::string& value);
  void set_file_id(std::string&& value);
  void set_file_id(const char* value);
  void set_file_id(const char* value, size_t size);
  std::string* mutable_file_id();
  std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // bytes file_content = 2;
  void clear_file_content();
  const std::string& file_content() const;
  void set_file_content(const std::string& value);
  void set_file_content(std::string&& value);
  void set_file_content(const char* value);
  void set_file_content(const void* value, size_t size);
  std::string* mutable_file_content();
  std::string* release_file_content();
  void set_allocated_file_content(std::string* file_content);
  private:
  const std::string& _internal_file_content() const;
  void _internal_set_file_content(const std::string& value);
  std::string* _internal_mutable_file_content();
  public:

  // @@protoc_insertion_point(class_scope:im.FileDownloadData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class FileUploadData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:im.FileUploadData) */ {
 public:
  inline FileUploadData() : FileUploadData(nullptr) {}
  virtual ~FileUploadData();

  FileUploadData(const FileUploadData& from);
  FileUploadData(FileUploadData&& from) noexcept
    : FileUploadData() {
    *this = ::std::move(from);
  }

  inline FileUploadData& operator=(const FileUploadData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileUploadData& operator=(FileUploadData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileUploadData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileUploadData* internal_default_instance() {
    return reinterpret_cast<const FileUploadData*>(
               &_FileUploadData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FileUploadData& a, FileUploadData& b) {
    a.Swap(&b);
  }
  inline void Swap(FileUploadData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileUploadData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileUploadData* New() const final {
    return CreateMaybeMessage<FileUploadData>(nullptr);
  }

  FileUploadData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileUploadData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileUploadData& from);
  void MergeFrom(const FileUploadData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileUploadData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.FileUploadData";
  }
  protected:
  explicit FileUploadData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kFileContentFieldNumber = 3,
    kFileSizeFieldNumber = 2,
  };
  // string file_name = 1;
  void clear_file_name();
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // bytes file_content = 3;
  void clear_file_content();
  const std::string& file_content() const;
  void set_file_content(const std::string& value);
  void set_file_content(std::string&& value);
  void set_file_content(const char* value);
  void set_file_content(const void* value, size_t size);
  std::string* mutable_file_content();
  std::string* release_file_content();
  void set_allocated_file_content(std::string* file_content);
  private:
  const std::string& _internal_file_content() const;
  void _internal_set_file_content(const std::string& value);
  std::string* _internal_mutable_file_content();
  public:

  // int64 file_size = 2;
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::int64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:im.FileUploadData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_content_;
  ::PROTOBUF_NAMESPACE_ID::int64 file_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserInfo

// string user_id = 1;
inline void UserInfo::clear_user_id() {
  user_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:im.UserInfo.user_id)
  return _internal_user_id();
}
inline void UserInfo::set_user_id(const std::string& value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:im.UserInfo.user_id)
}
inline std::string* UserInfo::mutable_user_id() {
  // @@protoc_insertion_point(field_mutable:im.UserInfo.user_id)
  return _internal_mutable_user_id();
}
inline const std::string& UserInfo::_internal_user_id() const {
  return user_id_.Get();
}
inline void UserInfo::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserInfo::set_user_id(std::string&& value) {
  
  user_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.UserInfo.user_id)
}
inline void UserInfo::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.UserInfo.user_id)
}
inline void UserInfo::set_user_id(const char* value,
    size_t size) {
  
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.UserInfo.user_id)
}
inline std::string* UserInfo::_internal_mutable_user_id() {
  
  return user_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserInfo::release_user_id() {
  // @@protoc_insertion_point(field_release:im.UserInfo.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserInfo::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.UserInfo.user_id)
}

// string nickname = 2;
inline void UserInfo::clear_nickname() {
  nickname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UserInfo::nickname() const {
  // @@protoc_insertion_point(field_get:im.UserInfo.nickname)
  return _internal_nickname();
}
inline void UserInfo::set_nickname(const std::string& value) {
  _internal_set_nickname(value);
  // @@protoc_insertion_point(field_set:im.UserInfo.nickname)
}
inline std::string* UserInfo::mutable_nickname() {
  // @@protoc_insertion_point(field_mutable:im.UserInfo.nickname)
  return _internal_mutable_nickname();
}
inline const std::string& UserInfo::_internal_nickname() const {
  return nickname_.Get();
}
inline void UserInfo::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserInfo::set_nickname(std::string&& value) {
  
  nickname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.UserInfo.nickname)
}
inline void UserInfo::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.UserInfo.nickname)
}
inline void UserInfo::set_nickname(const char* value,
    size_t size) {
  
  nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.UserInfo.nickname)
}
inline std::string* UserInfo::_internal_mutable_nickname() {
  
  return nickname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:im.UserInfo.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.UserInfo.nickname)
}

// string description = 3;
inline void UserInfo::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UserInfo::description() const {
  // @@protoc_insertion_point(field_get:im.UserInfo.description)
  return _internal_description();
}
inline void UserInfo::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:im.UserInfo.description)
}
inline std::string* UserInfo::mutable_description() {
  // @@protoc_insertion_point(field_mutable:im.UserInfo.description)
  return _internal_mutable_description();
}
inline const std::string& UserInfo::_internal_description() const {
  return description_.Get();
}
inline void UserInfo::_internal_set_description(const std::string& value) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserInfo::set_description(std::string&& value) {
  
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.UserInfo.description)
}
inline void UserInfo::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.UserInfo.description)
}
inline void UserInfo::set_description(const char* value,
    size_t size) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.UserInfo.description)
}
inline std::string* UserInfo::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserInfo::release_description() {
  // @@protoc_insertion_point(field_release:im.UserInfo.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.UserInfo.description)
}

// string phone = 4;
inline void UserInfo::clear_phone() {
  phone_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UserInfo::phone() const {
  // @@protoc_insertion_point(field_get:im.UserInfo.phone)
  return _internal_phone();
}
inline void UserInfo::set_phone(const std::string& value) {
  _internal_set_phone(value);
  // @@protoc_insertion_point(field_set:im.UserInfo.phone)
}
inline std::string* UserInfo::mutable_phone() {
  // @@protoc_insertion_point(field_mutable:im.UserInfo.phone)
  return _internal_mutable_phone();
}
inline const std::string& UserInfo::_internal_phone() const {
  return phone_.Get();
}
inline void UserInfo::_internal_set_phone(const std::string& value) {
  
  phone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserInfo::set_phone(std::string&& value) {
  
  phone_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.UserInfo.phone)
}
inline void UserInfo::set_phone(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  phone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.UserInfo.phone)
}
inline void UserInfo::set_phone(const char* value,
    size_t size) {
  
  phone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.UserInfo.phone)
}
inline std::string* UserInfo::_internal_mutable_phone() {
  
  return phone_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserInfo::release_phone() {
  // @@protoc_insertion_point(field_release:im.UserInfo.phone)
  return phone_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserInfo::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    
  } else {
    
  }
  phone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.UserInfo.phone)
}

// bytes avatar = 5;
inline void UserInfo::clear_avatar() {
  avatar_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UserInfo::avatar() const {
  // @@protoc_insertion_point(field_get:im.UserInfo.avatar)
  return _internal_avatar();
}
inline void UserInfo::set_avatar(const std::string& value) {
  _internal_set_avatar(value);
  // @@protoc_insertion_point(field_set:im.UserInfo.avatar)
}
inline std::string* UserInfo::mutable_avatar() {
  // @@protoc_insertion_point(field_mutable:im.UserInfo.avatar)
  return _internal_mutable_avatar();
}
inline const std::string& UserInfo::_internal_avatar() const {
  return avatar_.Get();
}
inline void UserInfo::_internal_set_avatar(const std::string& value) {
  
  avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserInfo::set_avatar(std::string&& value) {
  
  avatar_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.UserInfo.avatar)
}
inline void UserInfo::set_avatar(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.UserInfo.avatar)
}
inline void UserInfo::set_avatar(const void* value,
    size_t size) {
  
  avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.UserInfo.avatar)
}
inline std::string* UserInfo::_internal_mutable_avatar() {
  
  return avatar_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:im.UserInfo.avatar)
  return avatar_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserInfo::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    
  } else {
    
  }
  avatar_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.UserInfo.avatar)
}

// -------------------------------------------------------------------

// ChatSessionInfo

// string single_chat_friend_id = 1;
inline bool ChatSessionInfo::_internal_has_single_chat_friend_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatSessionInfo::has_single_chat_friend_id() const {
  return _internal_has_single_chat_friend_id();
}
inline void ChatSessionInfo::clear_single_chat_friend_id() {
  single_chat_friend_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatSessionInfo::single_chat_friend_id() const {
  // @@protoc_insertion_point(field_get:im.ChatSessionInfo.single_chat_friend_id)
  return _internal_single_chat_friend_id();
}
inline void ChatSessionInfo::set_single_chat_friend_id(const std::string& value) {
  _internal_set_single_chat_friend_id(value);
  // @@protoc_insertion_point(field_set:im.ChatSessionInfo.single_chat_friend_id)
}
inline std::string* ChatSessionInfo::mutable_single_chat_friend_id() {
  // @@protoc_insertion_point(field_mutable:im.ChatSessionInfo.single_chat_friend_id)
  return _internal_mutable_single_chat_friend_id();
}
inline const std::string& ChatSessionInfo::_internal_single_chat_friend_id() const {
  return single_chat_friend_id_.Get();
}
inline void ChatSessionInfo::_internal_set_single_chat_friend_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  single_chat_friend_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChatSessionInfo::set_single_chat_friend_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  single_chat_friend_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.ChatSessionInfo.single_chat_friend_id)
}
inline void ChatSessionInfo::set_single_chat_friend_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  single_chat_friend_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.ChatSessionInfo.single_chat_friend_id)
}
inline void ChatSessionInfo::set_single_chat_friend_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  single_chat_friend_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.ChatSessionInfo.single_chat_friend_id)
}
inline std::string* ChatSessionInfo::_internal_mutable_single_chat_friend_id() {
  _has_bits_[0] |= 0x00000001u;
  return single_chat_friend_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChatSessionInfo::release_single_chat_friend_id() {
  // @@protoc_insertion_point(field_release:im.ChatSessionInfo.single_chat_friend_id)
  if (!_internal_has_single_chat_friend_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return single_chat_friend_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChatSessionInfo::set_allocated_single_chat_friend_id(std::string* single_chat_friend_id) {
  if (single_chat_friend_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  single_chat_friend_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), single_chat_friend_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.ChatSessionInfo.single_chat_friend_id)
}

// string chat_session_id = 2;
inline void ChatSessionInfo::clear_chat_session_id() {
  chat_session_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ChatSessionInfo::chat_session_id() const {
  // @@protoc_insertion_point(field_get:im.ChatSessionInfo.chat_session_id)
  return _internal_chat_session_id();
}
inline void ChatSessionInfo::set_chat_session_id(const std::string& value) {
  _internal_set_chat_session_id(value);
  // @@protoc_insertion_point(field_set:im.ChatSessionInfo.chat_session_id)
}
inline std::string* ChatSessionInfo::mutable_chat_session_id() {
  // @@protoc_insertion_point(field_mutable:im.ChatSessionInfo.chat_session_id)
  return _internal_mutable_chat_session_id();
}
inline const std::string& ChatSessionInfo::_internal_chat_session_id() const {
  return chat_session_id_.Get();
}
inline void ChatSessionInfo::_internal_set_chat_session_id(const std::string& value) {
  
  chat_session_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChatSessionInfo::set_chat_session_id(std::string&& value) {
  
  chat_session_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.ChatSessionInfo.chat_session_id)
}
inline void ChatSessionInfo::set_chat_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chat_session_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.ChatSessionInfo.chat_session_id)
}
inline void ChatSessionInfo::set_chat_session_id(const char* value,
    size_t size) {
  
  chat_session_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.ChatSessionInfo.chat_session_id)
}
inline std::string* ChatSessionInfo::_internal_mutable_chat_session_id() {
  
  return chat_session_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChatSessionInfo::release_chat_session_id() {
  // @@protoc_insertion_point(field_release:im.ChatSessionInfo.chat_session_id)
  return chat_session_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChatSessionInfo::set_allocated_chat_session_id(std::string* chat_session_id) {
  if (chat_session_id != nullptr) {
    
  } else {
    
  }
  chat_session_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chat_session_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.ChatSessionInfo.chat_session_id)
}

// string chat_session_name = 3;
inline void ChatSessionInfo::clear_chat_session_name() {
  chat_session_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ChatSessionInfo::chat_session_name() const {
  // @@protoc_insertion_point(field_get:im.ChatSessionInfo.chat_session_name)
  return _internal_chat_session_name();
}
inline void ChatSessionInfo::set_chat_session_name(const std::string& value) {
  _internal_set_chat_session_name(value);
  // @@protoc_insertion_point(field_set:im.ChatSessionInfo.chat_session_name)
}
inline std::string* ChatSessionInfo::mutable_chat_session_name() {
  // @@protoc_insertion_point(field_mutable:im.ChatSessionInfo.chat_session_name)
  return _internal_mutable_chat_session_name();
}
inline const std::string& ChatSessionInfo::_internal_chat_session_name() const {
  return chat_session_name_.Get();
}
inline void ChatSessionInfo::_internal_set_chat_session_name(const std::string& value) {
  
  chat_session_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChatSessionInfo::set_chat_session_name(std::string&& value) {
  
  chat_session_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.ChatSessionInfo.chat_session_name)
}
inline void ChatSessionInfo::set_chat_session_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chat_session_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.ChatSessionInfo.chat_session_name)
}
inline void ChatSessionInfo::set_chat_session_name(const char* value,
    size_t size) {
  
  chat_session_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.ChatSessionInfo.chat_session_name)
}
inline std::string* ChatSessionInfo::_internal_mutable_chat_session_name() {
  
  return chat_session_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChatSessionInfo::release_chat_session_name() {
  // @@protoc_insertion_point(field_release:im.ChatSessionInfo.chat_session_name)
  return chat_session_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChatSessionInfo::set_allocated_chat_session_name(std::string* chat_session_name) {
  if (chat_session_name != nullptr) {
    
  } else {
    
  }
  chat_session_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chat_session_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.ChatSessionInfo.chat_session_name)
}

// .im.MessageInfo prev_message = 4;
inline bool ChatSessionInfo::_internal_has_prev_message() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || prev_message_ != nullptr);
  return value;
}
inline bool ChatSessionInfo::has_prev_message() const {
  return _internal_has_prev_message();
}
inline void ChatSessionInfo::clear_prev_message() {
  if (GetArena() == nullptr && prev_message_ != nullptr) {
    delete prev_message_;
  }
  prev_message_ = nullptr;
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::im::MessageInfo& ChatSessionInfo::_internal_prev_message() const {
  const ::im::MessageInfo* p = prev_message_;
  return p != nullptr ? *p : *reinterpret_cast<const ::im::MessageInfo*>(
      &::im::_MessageInfo_default_instance_);
}
inline const ::im::MessageInfo& ChatSessionInfo::prev_message() const {
  // @@protoc_insertion_point(field_get:im.ChatSessionInfo.prev_message)
  return _internal_prev_message();
}
inline void ChatSessionInfo::unsafe_arena_set_allocated_prev_message(
    ::im::MessageInfo* prev_message) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_message_);
  }
  prev_message_ = prev_message;
  if (prev_message) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.ChatSessionInfo.prev_message)
}
inline ::im::MessageInfo* ChatSessionInfo::release_prev_message() {
  _has_bits_[0] &= ~0x00000004u;
  ::im::MessageInfo* temp = prev_message_;
  prev_message_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::im::MessageInfo* ChatSessionInfo::unsafe_arena_release_prev_message() {
  // @@protoc_insertion_point(field_release:im.ChatSessionInfo.prev_message)
  _has_bits_[0] &= ~0x00000004u;
  ::im::MessageInfo* temp = prev_message_;
  prev_message_ = nullptr;
  return temp;
}
inline ::im::MessageInfo* ChatSessionInfo::_internal_mutable_prev_message() {
  _has_bits_[0] |= 0x00000004u;
  if (prev_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::im::MessageInfo>(GetArena());
    prev_message_ = p;
  }
  return prev_message_;
}
inline ::im::MessageInfo* ChatSessionInfo::mutable_prev_message() {
  // @@protoc_insertion_point(field_mutable:im.ChatSessionInfo.prev_message)
  return _internal_mutable_prev_message();
}
inline void ChatSessionInfo::set_allocated_prev_message(::im::MessageInfo* prev_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete prev_message_;
  }
  if (prev_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(prev_message);
    if (message_arena != submessage_arena) {
      prev_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  prev_message_ = prev_message;
  // @@protoc_insertion_point(field_set_allocated:im.ChatSessionInfo.prev_message)
}

// bytes avatar = 5;
inline bool ChatSessionInfo::_internal_has_avatar() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChatSessionInfo::has_avatar() const {
  return _internal_has_avatar();
}
inline void ChatSessionInfo::clear_avatar() {
  avatar_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChatSessionInfo::avatar() const {
  // @@protoc_insertion_point(field_get:im.ChatSessionInfo.avatar)
  return _internal_avatar();
}
inline void ChatSessionInfo::set_avatar(const std::string& value) {
  _internal_set_avatar(value);
  // @@protoc_insertion_point(field_set:im.ChatSessionInfo.avatar)
}
inline std::string* ChatSessionInfo::mutable_avatar() {
  // @@protoc_insertion_point(field_mutable:im.ChatSessionInfo.avatar)
  return _internal_mutable_avatar();
}
inline const std::string& ChatSessionInfo::_internal_avatar() const {
  return avatar_.Get();
}
inline void ChatSessionInfo::_internal_set_avatar(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChatSessionInfo::set_avatar(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  avatar_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.ChatSessionInfo.avatar)
}
inline void ChatSessionInfo::set_avatar(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.ChatSessionInfo.avatar)
}
inline void ChatSessionInfo::set_avatar(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.ChatSessionInfo.avatar)
}
inline std::string* ChatSessionInfo::_internal_mutable_avatar() {
  _has_bits_[0] |= 0x00000002u;
  return avatar_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChatSessionInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:im.ChatSessionInfo.avatar)
  if (!_internal_has_avatar()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return avatar_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChatSessionInfo::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  avatar_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.ChatSessionInfo.avatar)
}

// -------------------------------------------------------------------

// StringMessageInfo

// string content = 1;
inline void StringMessageInfo::clear_content() {
  content_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& StringMessageInfo::content() const {
  // @@protoc_insertion_point(field_get:im.StringMessageInfo.content)
  return _internal_content();
}
inline void StringMessageInfo::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:im.StringMessageInfo.content)
}
inline std::string* StringMessageInfo::mutable_content() {
  // @@protoc_insertion_point(field_mutable:im.StringMessageInfo.content)
  return _internal_mutable_content();
}
inline const std::string& StringMessageInfo::_internal_content() const {
  return content_.Get();
}
inline void StringMessageInfo::_internal_set_content(const std::string& value) {
  
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StringMessageInfo::set_content(std::string&& value) {
  
  content_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.StringMessageInfo.content)
}
inline void StringMessageInfo::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.StringMessageInfo.content)
}
inline void StringMessageInfo::set_content(const char* value,
    size_t size) {
  
  content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.StringMessageInfo.content)
}
inline std::string* StringMessageInfo::_internal_mutable_content() {
  
  return content_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StringMessageInfo::release_content() {
  // @@protoc_insertion_point(field_release:im.StringMessageInfo.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StringMessageInfo::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.StringMessageInfo.content)
}

// -------------------------------------------------------------------

// ImageMessageInfo

// string file_id = 1;
inline bool ImageMessageInfo::_internal_has_file_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageMessageInfo::has_file_id() const {
  return _internal_has_file_id();
}
inline void ImageMessageInfo::clear_file_id() {
  file_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageMessageInfo::file_id() const {
  // @@protoc_insertion_point(field_get:im.ImageMessageInfo.file_id)
  return _internal_file_id();
}
inline void ImageMessageInfo::set_file_id(const std::string& value) {
  _internal_set_file_id(value);
  // @@protoc_insertion_point(field_set:im.ImageMessageInfo.file_id)
}
inline std::string* ImageMessageInfo::mutable_file_id() {
  // @@protoc_insertion_point(field_mutable:im.ImageMessageInfo.file_id)
  return _internal_mutable_file_id();
}
inline const std::string& ImageMessageInfo::_internal_file_id() const {
  return file_id_.Get();
}
inline void ImageMessageInfo::_internal_set_file_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageMessageInfo::set_file_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.ImageMessageInfo.file_id)
}
inline void ImageMessageInfo::set_file_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.ImageMessageInfo.file_id)
}
inline void ImageMessageInfo::set_file_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.ImageMessageInfo.file_id)
}
inline std::string* ImageMessageInfo::_internal_mutable_file_id() {
  _has_bits_[0] |= 0x00000001u;
  return file_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageMessageInfo::release_file_id() {
  // @@protoc_insertion_point(field_release:im.ImageMessageInfo.file_id)
  if (!_internal_has_file_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return file_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageMessageInfo::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.ImageMessageInfo.file_id)
}

// bytes image_content = 2;
inline bool ImageMessageInfo::_internal_has_image_content() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImageMessageInfo::has_image_content() const {
  return _internal_has_image_content();
}
inline void ImageMessageInfo::clear_image_content() {
  image_content_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ImageMessageInfo::image_content() const {
  // @@protoc_insertion_point(field_get:im.ImageMessageInfo.image_content)
  return _internal_image_content();
}
inline void ImageMessageInfo::set_image_content(const std::string& value) {
  _internal_set_image_content(value);
  // @@protoc_insertion_point(field_set:im.ImageMessageInfo.image_content)
}
inline std::string* ImageMessageInfo::mutable_image_content() {
  // @@protoc_insertion_point(field_mutable:im.ImageMessageInfo.image_content)
  return _internal_mutable_image_content();
}
inline const std::string& ImageMessageInfo::_internal_image_content() const {
  return image_content_.Get();
}
inline void ImageMessageInfo::_internal_set_image_content(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  image_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageMessageInfo::set_image_content(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  image_content_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.ImageMessageInfo.image_content)
}
inline void ImageMessageInfo::set_image_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  image_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.ImageMessageInfo.image_content)
}
inline void ImageMessageInfo::set_image_content(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  image_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.ImageMessageInfo.image_content)
}
inline std::string* ImageMessageInfo::_internal_mutable_image_content() {
  _has_bits_[0] |= 0x00000002u;
  return image_content_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageMessageInfo::release_image_content() {
  // @@protoc_insertion_point(field_release:im.ImageMessageInfo.image_content)
  if (!_internal_has_image_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return image_content_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageMessageInfo::set_allocated_image_content(std::string* image_content) {
  if (image_content != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  image_content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.ImageMessageInfo.image_content)
}

// -------------------------------------------------------------------

// FileMessageInfo

// string file_id = 1;
inline bool FileMessageInfo::_internal_has_file_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileMessageInfo::has_file_id() const {
  return _internal_has_file_id();
}
inline void FileMessageInfo::clear_file_id() {
  file_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileMessageInfo::file_id() const {
  // @@protoc_insertion_point(field_get:im.FileMessageInfo.file_id)
  return _internal_file_id();
}
inline void FileMessageInfo::set_file_id(const std::string& value) {
  _internal_set_file_id(value);
  // @@protoc_insertion_point(field_set:im.FileMessageInfo.file_id)
}
inline std::string* FileMessageInfo::mutable_file_id() {
  // @@protoc_insertion_point(field_mutable:im.FileMessageInfo.file_id)
  return _internal_mutable_file_id();
}
inline const std::string& FileMessageInfo::_internal_file_id() const {
  return file_id_.Get();
}
inline void FileMessageInfo::_internal_set_file_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileMessageInfo::set_file_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.FileMessageInfo.file_id)
}
inline void FileMessageInfo::set_file_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.FileMessageInfo.file_id)
}
inline void FileMessageInfo::set_file_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.FileMessageInfo.file_id)
}
inline std::string* FileMessageInfo::_internal_mutable_file_id() {
  _has_bits_[0] |= 0x00000001u;
  return file_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileMessageInfo::release_file_id() {
  // @@protoc_insertion_point(field_release:im.FileMessageInfo.file_id)
  if (!_internal_has_file_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return file_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileMessageInfo::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.FileMessageInfo.file_id)
}

// int64 file_size = 2;
inline bool FileMessageInfo::_internal_has_file_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FileMessageInfo::has_file_size() const {
  return _internal_has_file_size();
}
inline void FileMessageInfo::clear_file_size() {
  file_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileMessageInfo::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileMessageInfo::file_size() const {
  // @@protoc_insertion_point(field_get:im.FileMessageInfo.file_size)
  return _internal_file_size();
}
inline void FileMessageInfo::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  file_size_ = value;
}
inline void FileMessageInfo::set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:im.FileMessageInfo.file_size)
}

// string file_name = 3;
inline bool FileMessageInfo::_internal_has_file_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileMessageInfo::has_file_name() const {
  return _internal_has_file_name();
}
inline void FileMessageInfo::clear_file_name() {
  file_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileMessageInfo::file_name() const {
  // @@protoc_insertion_point(field_get:im.FileMessageInfo.file_name)
  return _internal_file_name();
}
inline void FileMessageInfo::set_file_name(const std::string& value) {
  _internal_set_file_name(value);
  // @@protoc_insertion_point(field_set:im.FileMessageInfo.file_name)
}
inline std::string* FileMessageInfo::mutable_file_name() {
  // @@protoc_insertion_point(field_mutable:im.FileMessageInfo.file_name)
  return _internal_mutable_file_name();
}
inline const std::string& FileMessageInfo::_internal_file_name() const {
  return file_name_.Get();
}
inline void FileMessageInfo::_internal_set_file_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileMessageInfo::set_file_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  file_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.FileMessageInfo.file_name)
}
inline void FileMessageInfo::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.FileMessageInfo.file_name)
}
inline void FileMessageInfo::set_file_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.FileMessageInfo.file_name)
}
inline std::string* FileMessageInfo::_internal_mutable_file_name() {
  _has_bits_[0] |= 0x00000002u;
  return file_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileMessageInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:im.FileMessageInfo.file_name)
  if (!_internal_has_file_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return file_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileMessageInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.FileMessageInfo.file_name)
}

// bytes file_contents = 4;
inline bool FileMessageInfo::_internal_has_file_contents() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FileMessageInfo::has_file_contents() const {
  return _internal_has_file_contents();
}
inline void FileMessageInfo::clear_file_contents() {
  file_contents_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FileMessageInfo::file_contents() const {
  // @@protoc_insertion_point(field_get:im.FileMessageInfo.file_contents)
  return _internal_file_contents();
}
inline void FileMessageInfo::set_file_contents(const std::string& value) {
  _internal_set_file_contents(value);
  // @@protoc_insertion_point(field_set:im.FileMessageInfo.file_contents)
}
inline std::string* FileMessageInfo::mutable_file_contents() {
  // @@protoc_insertion_point(field_mutable:im.FileMessageInfo.file_contents)
  return _internal_mutable_file_contents();
}
inline const std::string& FileMessageInfo::_internal_file_contents() const {
  return file_contents_.Get();
}
inline void FileMessageInfo::_internal_set_file_contents(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileMessageInfo::set_file_contents(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  file_contents_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.FileMessageInfo.file_contents)
}
inline void FileMessageInfo::set_file_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.FileMessageInfo.file_contents)
}
inline void FileMessageInfo::set_file_contents(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.FileMessageInfo.file_contents)
}
inline std::string* FileMessageInfo::_internal_mutable_file_contents() {
  _has_bits_[0] |= 0x00000004u;
  return file_contents_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileMessageInfo::release_file_contents() {
  // @@protoc_insertion_point(field_release:im.FileMessageInfo.file_contents)
  if (!_internal_has_file_contents()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return file_contents_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileMessageInfo::set_allocated_file_contents(std::string* file_contents) {
  if (file_contents != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  file_contents_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_contents,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.FileMessageInfo.file_contents)
}

// -------------------------------------------------------------------

// SpeechMessageInfo

// string file_id = 1;
inline bool SpeechMessageInfo::_internal_has_file_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeechMessageInfo::has_file_id() const {
  return _internal_has_file_id();
}
inline void SpeechMessageInfo::clear_file_id() {
  file_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SpeechMessageInfo::file_id() const {
  // @@protoc_insertion_point(field_get:im.SpeechMessageInfo.file_id)
  return _internal_file_id();
}
inline void SpeechMessageInfo::set_file_id(const std::string& value) {
  _internal_set_file_id(value);
  // @@protoc_insertion_point(field_set:im.SpeechMessageInfo.file_id)
}
inline std::string* SpeechMessageInfo::mutable_file_id() {
  // @@protoc_insertion_point(field_mutable:im.SpeechMessageInfo.file_id)
  return _internal_mutable_file_id();
}
inline const std::string& SpeechMessageInfo::_internal_file_id() const {
  return file_id_.Get();
}
inline void SpeechMessageInfo::_internal_set_file_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SpeechMessageInfo::set_file_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.SpeechMessageInfo.file_id)
}
inline void SpeechMessageInfo::set_file_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.SpeechMessageInfo.file_id)
}
inline void SpeechMessageInfo::set_file_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.SpeechMessageInfo.file_id)
}
inline std::string* SpeechMessageInfo::_internal_mutable_file_id() {
  _has_bits_[0] |= 0x00000001u;
  return file_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SpeechMessageInfo::release_file_id() {
  // @@protoc_insertion_point(field_release:im.SpeechMessageInfo.file_id)
  if (!_internal_has_file_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return file_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpeechMessageInfo::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.SpeechMessageInfo.file_id)
}

// bytes file_contents = 2;
inline bool SpeechMessageInfo::_internal_has_file_contents() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpeechMessageInfo::has_file_contents() const {
  return _internal_has_file_contents();
}
inline void SpeechMessageInfo::clear_file_contents() {
  file_contents_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SpeechMessageInfo::file_contents() const {
  // @@protoc_insertion_point(field_get:im.SpeechMessageInfo.file_contents)
  return _internal_file_contents();
}
inline void SpeechMessageInfo::set_file_contents(const std::string& value) {
  _internal_set_file_contents(value);
  // @@protoc_insertion_point(field_set:im.SpeechMessageInfo.file_contents)
}
inline std::string* SpeechMessageInfo::mutable_file_contents() {
  // @@protoc_insertion_point(field_mutable:im.SpeechMessageInfo.file_contents)
  return _internal_mutable_file_contents();
}
inline const std::string& SpeechMessageInfo::_internal_file_contents() const {
  return file_contents_.Get();
}
inline void SpeechMessageInfo::_internal_set_file_contents(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SpeechMessageInfo::set_file_contents(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  file_contents_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.SpeechMessageInfo.file_contents)
}
inline void SpeechMessageInfo::set_file_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.SpeechMessageInfo.file_contents)
}
inline void SpeechMessageInfo::set_file_contents(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.SpeechMessageInfo.file_contents)
}
inline std::string* SpeechMessageInfo::_internal_mutable_file_contents() {
  _has_bits_[0] |= 0x00000002u;
  return file_contents_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SpeechMessageInfo::release_file_contents() {
  // @@protoc_insertion_point(field_release:im.SpeechMessageInfo.file_contents)
  if (!_internal_has_file_contents()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return file_contents_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpeechMessageInfo::set_allocated_file_contents(std::string* file_contents) {
  if (file_contents != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_contents_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_contents,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.SpeechMessageInfo.file_contents)
}

// -------------------------------------------------------------------

// MessageContent

// .im.MessageType message_type = 1;
inline void MessageContent::clear_message_type() {
  message_type_ = 0;
}
inline ::im::MessageType MessageContent::_internal_message_type() const {
  return static_cast< ::im::MessageType >(message_type_);
}
inline ::im::MessageType MessageContent::message_type() const {
  // @@protoc_insertion_point(field_get:im.MessageContent.message_type)
  return _internal_message_type();
}
inline void MessageContent::_internal_set_message_type(::im::MessageType value) {
  
  message_type_ = value;
}
inline void MessageContent::set_message_type(::im::MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:im.MessageContent.message_type)
}

// .im.StringMessageInfo string_message = 2;
inline bool MessageContent::_internal_has_string_message() const {
  return msg_content_case() == kStringMessage;
}
inline bool MessageContent::has_string_message() const {
  return _internal_has_string_message();
}
inline void MessageContent::set_has_string_message() {
  _oneof_case_[0] = kStringMessage;
}
inline void MessageContent::clear_string_message() {
  if (_internal_has_string_message()) {
    if (GetArena() == nullptr) {
      delete msg_content_.string_message_;
    }
    clear_has_msg_content();
  }
}
inline ::im::StringMessageInfo* MessageContent::release_string_message() {
  // @@protoc_insertion_point(field_release:im.MessageContent.string_message)
  if (_internal_has_string_message()) {
    clear_has_msg_content();
      ::im::StringMessageInfo* temp = msg_content_.string_message_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_content_.string_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::im::StringMessageInfo& MessageContent::_internal_string_message() const {
  return _internal_has_string_message()
      ? *msg_content_.string_message_
      : *reinterpret_cast< ::im::StringMessageInfo*>(&::im::_StringMessageInfo_default_instance_);
}
inline const ::im::StringMessageInfo& MessageContent::string_message() const {
  // @@protoc_insertion_point(field_get:im.MessageContent.string_message)
  return _internal_string_message();
}
inline ::im::StringMessageInfo* MessageContent::unsafe_arena_release_string_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:im.MessageContent.string_message)
  if (_internal_has_string_message()) {
    clear_has_msg_content();
    ::im::StringMessageInfo* temp = msg_content_.string_message_;
    msg_content_.string_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageContent::unsafe_arena_set_allocated_string_message(::im::StringMessageInfo* string_message) {
  clear_msg_content();
  if (string_message) {
    set_has_string_message();
    msg_content_.string_message_ = string_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.MessageContent.string_message)
}
inline ::im::StringMessageInfo* MessageContent::_internal_mutable_string_message() {
  if (!_internal_has_string_message()) {
    clear_msg_content();
    set_has_string_message();
    msg_content_.string_message_ = CreateMaybeMessage< ::im::StringMessageInfo >(GetArena());
  }
  return msg_content_.string_message_;
}
inline ::im::StringMessageInfo* MessageContent::mutable_string_message() {
  // @@protoc_insertion_point(field_mutable:im.MessageContent.string_message)
  return _internal_mutable_string_message();
}

// .im.FileMessageInfo file_message = 3;
inline bool MessageContent::_internal_has_file_message() const {
  return msg_content_case() == kFileMessage;
}
inline bool MessageContent::has_file_message() const {
  return _internal_has_file_message();
}
inline void MessageContent::set_has_file_message() {
  _oneof_case_[0] = kFileMessage;
}
inline void MessageContent::clear_file_message() {
  if (_internal_has_file_message()) {
    if (GetArena() == nullptr) {
      delete msg_content_.file_message_;
    }
    clear_has_msg_content();
  }
}
inline ::im::FileMessageInfo* MessageContent::release_file_message() {
  // @@protoc_insertion_point(field_release:im.MessageContent.file_message)
  if (_internal_has_file_message()) {
    clear_has_msg_content();
      ::im::FileMessageInfo* temp = msg_content_.file_message_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_content_.file_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::im::FileMessageInfo& MessageContent::_internal_file_message() const {
  return _internal_has_file_message()
      ? *msg_content_.file_message_
      : *reinterpret_cast< ::im::FileMessageInfo*>(&::im::_FileMessageInfo_default_instance_);
}
inline const ::im::FileMessageInfo& MessageContent::file_message() const {
  // @@protoc_insertion_point(field_get:im.MessageContent.file_message)
  return _internal_file_message();
}
inline ::im::FileMessageInfo* MessageContent::unsafe_arena_release_file_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:im.MessageContent.file_message)
  if (_internal_has_file_message()) {
    clear_has_msg_content();
    ::im::FileMessageInfo* temp = msg_content_.file_message_;
    msg_content_.file_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageContent::unsafe_arena_set_allocated_file_message(::im::FileMessageInfo* file_message) {
  clear_msg_content();
  if (file_message) {
    set_has_file_message();
    msg_content_.file_message_ = file_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.MessageContent.file_message)
}
inline ::im::FileMessageInfo* MessageContent::_internal_mutable_file_message() {
  if (!_internal_has_file_message()) {
    clear_msg_content();
    set_has_file_message();
    msg_content_.file_message_ = CreateMaybeMessage< ::im::FileMessageInfo >(GetArena());
  }
  return msg_content_.file_message_;
}
inline ::im::FileMessageInfo* MessageContent::mutable_file_message() {
  // @@protoc_insertion_point(field_mutable:im.MessageContent.file_message)
  return _internal_mutable_file_message();
}

// .im.SpeechMessageInfo speech_message = 4;
inline bool MessageContent::_internal_has_speech_message() const {
  return msg_content_case() == kSpeechMessage;
}
inline bool MessageContent::has_speech_message() const {
  return _internal_has_speech_message();
}
inline void MessageContent::set_has_speech_message() {
  _oneof_case_[0] = kSpeechMessage;
}
inline void MessageContent::clear_speech_message() {
  if (_internal_has_speech_message()) {
    if (GetArena() == nullptr) {
      delete msg_content_.speech_message_;
    }
    clear_has_msg_content();
  }
}
inline ::im::SpeechMessageInfo* MessageContent::release_speech_message() {
  // @@protoc_insertion_point(field_release:im.MessageContent.speech_message)
  if (_internal_has_speech_message()) {
    clear_has_msg_content();
      ::im::SpeechMessageInfo* temp = msg_content_.speech_message_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_content_.speech_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::im::SpeechMessageInfo& MessageContent::_internal_speech_message() const {
  return _internal_has_speech_message()
      ? *msg_content_.speech_message_
      : *reinterpret_cast< ::im::SpeechMessageInfo*>(&::im::_SpeechMessageInfo_default_instance_);
}
inline const ::im::SpeechMessageInfo& MessageContent::speech_message() const {
  // @@protoc_insertion_point(field_get:im.MessageContent.speech_message)
  return _internal_speech_message();
}
inline ::im::SpeechMessageInfo* MessageContent::unsafe_arena_release_speech_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:im.MessageContent.speech_message)
  if (_internal_has_speech_message()) {
    clear_has_msg_content();
    ::im::SpeechMessageInfo* temp = msg_content_.speech_message_;
    msg_content_.speech_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageContent::unsafe_arena_set_allocated_speech_message(::im::SpeechMessageInfo* speech_message) {
  clear_msg_content();
  if (speech_message) {
    set_has_speech_message();
    msg_content_.speech_message_ = speech_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.MessageContent.speech_message)
}
inline ::im::SpeechMessageInfo* MessageContent::_internal_mutable_speech_message() {
  if (!_internal_has_speech_message()) {
    clear_msg_content();
    set_has_speech_message();
    msg_content_.speech_message_ = CreateMaybeMessage< ::im::SpeechMessageInfo >(GetArena());
  }
  return msg_content_.speech_message_;
}
inline ::im::SpeechMessageInfo* MessageContent::mutable_speech_message() {
  // @@protoc_insertion_point(field_mutable:im.MessageContent.speech_message)
  return _internal_mutable_speech_message();
}

// .im.ImageMessageInfo image_message = 5;
inline bool MessageContent::_internal_has_image_message() const {
  return msg_content_case() == kImageMessage;
}
inline bool MessageContent::has_image_message() const {
  return _internal_has_image_message();
}
inline void MessageContent::set_has_image_message() {
  _oneof_case_[0] = kImageMessage;
}
inline void MessageContent::clear_image_message() {
  if (_internal_has_image_message()) {
    if (GetArena() == nullptr) {
      delete msg_content_.image_message_;
    }
    clear_has_msg_content();
  }
}
inline ::im::ImageMessageInfo* MessageContent::release_image_message() {
  // @@protoc_insertion_point(field_release:im.MessageContent.image_message)
  if (_internal_has_image_message()) {
    clear_has_msg_content();
      ::im::ImageMessageInfo* temp = msg_content_.image_message_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_content_.image_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::im::ImageMessageInfo& MessageContent::_internal_image_message() const {
  return _internal_has_image_message()
      ? *msg_content_.image_message_
      : *reinterpret_cast< ::im::ImageMessageInfo*>(&::im::_ImageMessageInfo_default_instance_);
}
inline const ::im::ImageMessageInfo& MessageContent::image_message() const {
  // @@protoc_insertion_point(field_get:im.MessageContent.image_message)
  return _internal_image_message();
}
inline ::im::ImageMessageInfo* MessageContent::unsafe_arena_release_image_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:im.MessageContent.image_message)
  if (_internal_has_image_message()) {
    clear_has_msg_content();
    ::im::ImageMessageInfo* temp = msg_content_.image_message_;
    msg_content_.image_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageContent::unsafe_arena_set_allocated_image_message(::im::ImageMessageInfo* image_message) {
  clear_msg_content();
  if (image_message) {
    set_has_image_message();
    msg_content_.image_message_ = image_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.MessageContent.image_message)
}
inline ::im::ImageMessageInfo* MessageContent::_internal_mutable_image_message() {
  if (!_internal_has_image_message()) {
    clear_msg_content();
    set_has_image_message();
    msg_content_.image_message_ = CreateMaybeMessage< ::im::ImageMessageInfo >(GetArena());
  }
  return msg_content_.image_message_;
}
inline ::im::ImageMessageInfo* MessageContent::mutable_image_message() {
  // @@protoc_insertion_point(field_mutable:im.MessageContent.image_message)
  return _internal_mutable_image_message();
}

inline bool MessageContent::has_msg_content() const {
  return msg_content_case() != MSG_CONTENT_NOT_SET;
}
inline void MessageContent::clear_has_msg_content() {
  _oneof_case_[0] = MSG_CONTENT_NOT_SET;
}
inline MessageContent::MsgContentCase MessageContent::msg_content_case() const {
  return MessageContent::MsgContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MessageInfo

// string message_id = 1;
inline void MessageInfo::clear_message_id() {
  message_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MessageInfo::message_id() const {
  // @@protoc_insertion_point(field_get:im.MessageInfo.message_id)
  return _internal_message_id();
}
inline void MessageInfo::set_message_id(const std::string& value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:im.MessageInfo.message_id)
}
inline std::string* MessageInfo::mutable_message_id() {
  // @@protoc_insertion_point(field_mutable:im.MessageInfo.message_id)
  return _internal_mutable_message_id();
}
inline const std::string& MessageInfo::_internal_message_id() const {
  return message_id_.Get();
}
inline void MessageInfo::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessageInfo::set_message_id(std::string&& value) {
  
  message_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.MessageInfo.message_id)
}
inline void MessageInfo::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.MessageInfo.message_id)
}
inline void MessageInfo::set_message_id(const char* value,
    size_t size) {
  
  message_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.MessageInfo.message_id)
}
inline std::string* MessageInfo::_internal_mutable_message_id() {
  
  return message_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessageInfo::release_message_id() {
  // @@protoc_insertion_point(field_release:im.MessageInfo.message_id)
  return message_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageInfo::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.MessageInfo.message_id)
}

// string chat_session_id = 2;
inline void MessageInfo::clear_chat_session_id() {
  chat_session_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MessageInfo::chat_session_id() const {
  // @@protoc_insertion_point(field_get:im.MessageInfo.chat_session_id)
  return _internal_chat_session_id();
}
inline void MessageInfo::set_chat_session_id(const std::string& value) {
  _internal_set_chat_session_id(value);
  // @@protoc_insertion_point(field_set:im.MessageInfo.chat_session_id)
}
inline std::string* MessageInfo::mutable_chat_session_id() {
  // @@protoc_insertion_point(field_mutable:im.MessageInfo.chat_session_id)
  return _internal_mutable_chat_session_id();
}
inline const std::string& MessageInfo::_internal_chat_session_id() const {
  return chat_session_id_.Get();
}
inline void MessageInfo::_internal_set_chat_session_id(const std::string& value) {
  
  chat_session_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessageInfo::set_chat_session_id(std::string&& value) {
  
  chat_session_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.MessageInfo.chat_session_id)
}
inline void MessageInfo::set_chat_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chat_session_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.MessageInfo.chat_session_id)
}
inline void MessageInfo::set_chat_session_id(const char* value,
    size_t size) {
  
  chat_session_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.MessageInfo.chat_session_id)
}
inline std::string* MessageInfo::_internal_mutable_chat_session_id() {
  
  return chat_session_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessageInfo::release_chat_session_id() {
  // @@protoc_insertion_point(field_release:im.MessageInfo.chat_session_id)
  return chat_session_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageInfo::set_allocated_chat_session_id(std::string* chat_session_id) {
  if (chat_session_id != nullptr) {
    
  } else {
    
  }
  chat_session_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chat_session_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.MessageInfo.chat_session_id)
}

// int64 timestamp = 3;
inline void MessageInfo::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MessageInfo::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MessageInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:im.MessageInfo.timestamp)
  return _internal_timestamp();
}
inline void MessageInfo::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void MessageInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:im.MessageInfo.timestamp)
}

// .im.UserInfo sender = 4;
inline bool MessageInfo::_internal_has_sender() const {
  return this != internal_default_instance() && sender_ != nullptr;
}
inline bool MessageInfo::has_sender() const {
  return _internal_has_sender();
}
inline void MessageInfo::clear_sender() {
  if (GetArena() == nullptr && sender_ != nullptr) {
    delete sender_;
  }
  sender_ = nullptr;
}
inline const ::im::UserInfo& MessageInfo::_internal_sender() const {
  const ::im::UserInfo* p = sender_;
  return p != nullptr ? *p : *reinterpret_cast<const ::im::UserInfo*>(
      &::im::_UserInfo_default_instance_);
}
inline const ::im::UserInfo& MessageInfo::sender() const {
  // @@protoc_insertion_point(field_get:im.MessageInfo.sender)
  return _internal_sender();
}
inline void MessageInfo::unsafe_arena_set_allocated_sender(
    ::im::UserInfo* sender) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_);
  }
  sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.MessageInfo.sender)
}
inline ::im::UserInfo* MessageInfo::release_sender() {
  
  ::im::UserInfo* temp = sender_;
  sender_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::im::UserInfo* MessageInfo::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:im.MessageInfo.sender)
  
  ::im::UserInfo* temp = sender_;
  sender_ = nullptr;
  return temp;
}
inline ::im::UserInfo* MessageInfo::_internal_mutable_sender() {
  
  if (sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::im::UserInfo>(GetArena());
    sender_ = p;
  }
  return sender_;
}
inline ::im::UserInfo* MessageInfo::mutable_sender() {
  // @@protoc_insertion_point(field_mutable:im.MessageInfo.sender)
  return _internal_mutable_sender();
}
inline void MessageInfo::set_allocated_sender(::im::UserInfo* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sender_;
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sender);
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:im.MessageInfo.sender)
}

// .im.MessageContent message = 5;
inline bool MessageInfo::_internal_has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline bool MessageInfo::has_message() const {
  return _internal_has_message();
}
inline void MessageInfo::clear_message() {
  if (GetArena() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::im::MessageContent& MessageInfo::_internal_message() const {
  const ::im::MessageContent* p = message_;
  return p != nullptr ? *p : *reinterpret_cast<const ::im::MessageContent*>(
      &::im::_MessageContent_default_instance_);
}
inline const ::im::MessageContent& MessageInfo::message() const {
  // @@protoc_insertion_point(field_get:im.MessageInfo.message)
  return _internal_message();
}
inline void MessageInfo::unsafe_arena_set_allocated_message(
    ::im::MessageContent* message) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.MessageInfo.message)
}
inline ::im::MessageContent* MessageInfo::release_message() {
  
  ::im::MessageContent* temp = message_;
  message_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::im::MessageContent* MessageInfo::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:im.MessageInfo.message)
  
  ::im::MessageContent* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::im::MessageContent* MessageInfo::_internal_mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::im::MessageContent>(GetArena());
    message_ = p;
  }
  return message_;
}
inline ::im::MessageContent* MessageInfo::mutable_message() {
  // @@protoc_insertion_point(field_mutable:im.MessageInfo.message)
  return _internal_mutable_message();
}
inline void MessageInfo::set_allocated_message(::im::MessageContent* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:im.MessageInfo.message)
}

// -------------------------------------------------------------------

// FileDownloadData

// string file_id = 1;
inline void FileDownloadData::clear_file_id() {
  file_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FileDownloadData::file_id() const {
  // @@protoc_insertion_point(field_get:im.FileDownloadData.file_id)
  return _internal_file_id();
}
inline void FileDownloadData::set_file_id(const std::string& value) {
  _internal_set_file_id(value);
  // @@protoc_insertion_point(field_set:im.FileDownloadData.file_id)
}
inline std::string* FileDownloadData::mutable_file_id() {
  // @@protoc_insertion_point(field_mutable:im.FileDownloadData.file_id)
  return _internal_mutable_file_id();
}
inline const std::string& FileDownloadData::_internal_file_id() const {
  return file_id_.Get();
}
inline void FileDownloadData::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileDownloadData::set_file_id(std::string&& value) {
  
  file_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.FileDownloadData.file_id)
}
inline void FileDownloadData::set_file_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.FileDownloadData.file_id)
}
inline void FileDownloadData::set_file_id(const char* value,
    size_t size) {
  
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.FileDownloadData.file_id)
}
inline std::string* FileDownloadData::_internal_mutable_file_id() {
  
  return file_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileDownloadData::release_file_id() {
  // @@protoc_insertion_point(field_release:im.FileDownloadData.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileDownloadData::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.FileDownloadData.file_id)
}

// bytes file_content = 2;
inline void FileDownloadData::clear_file_content() {
  file_content_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FileDownloadData::file_content() const {
  // @@protoc_insertion_point(field_get:im.FileDownloadData.file_content)
  return _internal_file_content();
}
inline void FileDownloadData::set_file_content(const std::string& value) {
  _internal_set_file_content(value);
  // @@protoc_insertion_point(field_set:im.FileDownloadData.file_content)
}
inline std::string* FileDownloadData::mutable_file_content() {
  // @@protoc_insertion_point(field_mutable:im.FileDownloadData.file_content)
  return _internal_mutable_file_content();
}
inline const std::string& FileDownloadData::_internal_file_content() const {
  return file_content_.Get();
}
inline void FileDownloadData::_internal_set_file_content(const std::string& value) {
  
  file_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileDownloadData::set_file_content(std::string&& value) {
  
  file_content_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.FileDownloadData.file_content)
}
inline void FileDownloadData::set_file_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.FileDownloadData.file_content)
}
inline void FileDownloadData::set_file_content(const void* value,
    size_t size) {
  
  file_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.FileDownloadData.file_content)
}
inline std::string* FileDownloadData::_internal_mutable_file_content() {
  
  return file_content_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileDownloadData::release_file_content() {
  // @@protoc_insertion_point(field_release:im.FileDownloadData.file_content)
  return file_content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileDownloadData::set_allocated_file_content(std::string* file_content) {
  if (file_content != nullptr) {
    
  } else {
    
  }
  file_content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.FileDownloadData.file_content)
}

// -------------------------------------------------------------------

// FileUploadData

// string file_name = 1;
inline void FileUploadData::clear_file_name() {
  file_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FileUploadData::file_name() const {
  // @@protoc_insertion_point(field_get:im.FileUploadData.file_name)
  return _internal_file_name();
}
inline void FileUploadData::set_file_name(const std::string& value) {
  _internal_set_file_name(value);
  // @@protoc_insertion_point(field_set:im.FileUploadData.file_name)
}
inline std::string* FileUploadData::mutable_file_name() {
  // @@protoc_insertion_point(field_mutable:im.FileUploadData.file_name)
  return _internal_mutable_file_name();
}
inline const std::string& FileUploadData::_internal_file_name() const {
  return file_name_.Get();
}
inline void FileUploadData::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileUploadData::set_file_name(std::string&& value) {
  
  file_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.FileUploadData.file_name)
}
inline void FileUploadData::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.FileUploadData.file_name)
}
inline void FileUploadData::set_file_name(const char* value,
    size_t size) {
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.FileUploadData.file_name)
}
inline std::string* FileUploadData::_internal_mutable_file_name() {
  
  return file_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileUploadData::release_file_name() {
  // @@protoc_insertion_point(field_release:im.FileUploadData.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileUploadData::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.FileUploadData.file_name)
}

// int64 file_size = 2;
inline void FileUploadData::clear_file_size() {
  file_size_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileUploadData::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileUploadData::file_size() const {
  // @@protoc_insertion_point(field_get:im.FileUploadData.file_size)
  return _internal_file_size();
}
inline void FileUploadData::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  file_size_ = value;
}
inline void FileUploadData::set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:im.FileUploadData.file_size)
}

// bytes file_content = 3;
inline void FileUploadData::clear_file_content() {
  file_content_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FileUploadData::file_content() const {
  // @@protoc_insertion_point(field_get:im.FileUploadData.file_content)
  return _internal_file_content();
}
inline void FileUploadData::set_file_content(const std::string& value) {
  _internal_set_file_content(value);
  // @@protoc_insertion_point(field_set:im.FileUploadData.file_content)
}
inline std::string* FileUploadData::mutable_file_content() {
  // @@protoc_insertion_point(field_mutable:im.FileUploadData.file_content)
  return _internal_mutable_file_content();
}
inline const std::string& FileUploadData::_internal_file_content() const {
  return file_content_.Get();
}
inline void FileUploadData::_internal_set_file_content(const std::string& value) {
  
  file_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileUploadData::set_file_content(std::string&& value) {
  
  file_content_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:im.FileUploadData.file_content)
}
inline void FileUploadData::set_file_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:im.FileUploadData.file_content)
}
inline void FileUploadData::set_file_content(const void* value,
    size_t size) {
  
  file_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:im.FileUploadData.file_content)
}
inline std::string* FileUploadData::_internal_mutable_file_content() {
  
  return file_content_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileUploadData::release_file_content() {
  // @@protoc_insertion_point(field_release:im.FileUploadData.file_content)
  return file_content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileUploadData::set_allocated_file_content(std::string* file_content) {
  if (file_content != nullptr) {
    
  } else {
    
  }
  file_content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:im.FileUploadData.file_content)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace im

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::im::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::im::MessageType>() {
  return ::im::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_base_2eproto
